#' Standardized Sample Mean of Moment Functions
#'
#' @param x_data an n x k matrix of evaluated moment functions.
#' @param MARGIN a vector giving the subscripts which the function will be
#'   applied over. E.g., for a matrix 1 indicates rows, 2 indicates columns.
#'
#' @return a vector of the standardized sample mean of the moment functions.
#' @export
m_hat <- function(x_data, MARGIN = 2) {
  if (MARGIN == 1) {
    n <- ncol(x_data)
    mean_operation <- Rfast::rowmeans
    var_operation <- Rfast::rowVars
  } else if (MARGIN == 2) {
    n <- nrow(x_data)
    mean_operation <- Rfast::colmeans
    var_operation <- Rfast::colVars
  } else {
    stop("MARGIN must be 1 or 2.")
  }

  mu_hat <- mean_operation(x_data)
  # normalize by n instead of n-1 as in matlab code
  sigma_hat <- var_operation(x_data, std = T) * sqrt((n - 1) / n)

  # as in eq (A.13) and similar to eq. (4.2) in Andrews and Kwon (2023)
  return(mu_hat / sigma_hat)
}

#' Moment Inequality Function
#'
#' @param theta a vector containing the parameters of interest.
#' @param w_data an n x k matrix of product portfolio data.
#' @param a_matrix an n x (J0 + 1) matrix of estimated revenue differentials.
#' @param j0_vector a J0 x 2 matrix of ownership by the two firms.
#' @param v_bar a tuning parameter as in Assumption 4.2.
#' @param grid0 optional vector of length J0 containing the indices of the
#'   products in the market.
#' @param iv_matrix optional n x d_iv matrix of instruments.
#' @param dist_data an n x (J + 1) matrix of distances from the product
#'   factories to the cities.
#'
#' @return
#' @export
m_function <- function(theta, w_data, a_matrix, j0_vector, v_bar, grid0 = "all", iv_matrix = NULL, dist_data = NULL) {
  n <- nrow(a_matrix)
  J0 <- nrow(j0_vector)

  if (nrow(w_data) != n) {
    stop(sprintf("Wrong number of observations! %s != %s.", nrow(a_matrix), n))
  }

  ## step 1: select moments with non-zero variance using ml_indx & mu_indx
  #          the procedure follows the discussion of section 8.1

  aux1 <- Rfast::colsums(w_data)
  aux1 <- aux1[j0_vector[, 1]]

  if (grid0 == "all") {
    # include all the possible moments generated by products of coca-cola or energy-products
    ml_indx <- (1:J0)[aux1 < n]
    mu_indx <- (1:J0)[aux1 > 0]
  } else if (grid0 %in% 1:2) {
    # include only the possible moments generated by coca-cola (grid0=1) or energy-products (grid0=2)
    ml_indx <- (1:J0)[aux1 < n & j0_vector[, 2] == grid0]
    mu_indx <- (1:J0)[aux1 > 0 & j0_vector[, 2] == grid0]
  } else {
    stop(sprintf("grid 0 must be one of all,0,1. You entered %s.", grid0))
  }

  ## step 2: compute all the moment functions
  if (is.null(iv_matrix)) {
    # Create dummy IV vector
    z_matrix <- 1

    # Subset vector of estimated revenue differential in market i
    a_subset <- a_matrix[, 2:(J0 + 1)]
    # Subset vector of product portfolio of coca-cola and
    # energy-products in market i
    d_matrix <- w_data[, j0_vector[, 1]]

    ml_vec <- m_fun_lower(
      theta, d_matrix, a_subset, j0_vector, v_bar, z_matrix
    )
    mu_vec <- m_fun_upper(
      theta, d_matrix, a_subset, j0_vector, v_bar, z_matrix
    )

    x_data <- cbind(ml_vec[, ml_indx], mu_vec[, mu_indx])
  } else {
    # Create dummy IV "matrix"
    z0_matrix <- 1
    # employment rate
    z3_matrix <- as.numeric(iv_matrix[, 2] > median(iv_matrix[, 2]))
    # average income in market
    z5_matrix <- as.numeric(iv_matrix[, 3] > median(iv_matrix[, 3]))
    # median income in market
    z7_matrix <- as.numeric(iv_matrix[, 4] > median(iv_matrix[, 4]))

    # Subset vector of estimated revenue differential in market i
    a_subset <- a_matrix[, 2:(J0 + 1)]
    # Subset vector of product portfolio of coca-cola and
    # energy-products in market i
    d_matrix <- w_data[, j0_vector[, 1]]

    # Compute lower and upper bounds
    ml_vec0 <- m_fun_lower(
      theta, d_matrix, a_subset, j0_vector, v_bar, z0_matrix
    )
    mu_vec0 <- m_fun_upper(
      theta, d_matrix, a_subset, j0_vector, v_bar, z0_matrix
    )

    ml_vec3 <- m_fun_lower(
      theta, d_matrix, a_subset, j0_vector, v_bar, z3_matrix
    )
    mu_vec3 <- m_fun_upper(
      theta, d_matrix, a_subset, j0_vector, v_bar, z3_matrix
    )

    ml_vec5 <- m_fun_lower(
      theta, d_matrix, a_subset, j0_vector, v_bar, z5_matrix
    )
    mu_vec5 <- m_fun_upper(
      theta, d_matrix, a_subset, j0_vector, v_bar, z5_matrix
    )

    ml_vec7 <- m_fun_lower(
      theta, d_matrix, a_subset, j0_vector, v_bar, z7_matrix
    )
    mu_vec7 <- m_fun_upper(
      theta, d_matrix, a_subset, j0_vector, v_bar, z7_matrix
    )

    x_data <- cbind(
      ml_vec0[, ml_indx],
      mu_vec0[, mu_indx],
      ml_vec3[, ml_indx],
      mu_vec3[, mu_indx],
      ml_vec5[, ml_indx],
      mu_vec5[, mu_indx],
      ml_vec7[, ml_indx],
      mu_vec7[, mu_indx]
    )
  }

  ## step 3: select the computed moments using ml_indx & mu_indx defined in step 1
  salida <- x_data
  return(salida)
}

#' Lower Moment Inequality Function
#'
#' @param theta a vector containing the parameters of interest.
#' @param d_matrix an n x j0 matrix of product portfolio in each market.
#' @param a_subset an n x j0 matrix of estimated revenue differential in each
#'   market.
#' @param j0_vector a j0 x 2 matrix of ownership by the two firms.
#' @param v_bar a tuning parameter as in Assumption 4.2.
#' @param z_matrix an optional n x j0 matrix of instruments in each market.
#' @param dist_subset an optional n x j0 matrix of distance between products in
#'   each market.
#'
#' @return a j0-dimensional vector of lower moment inequalities.
#' @export
m_fun_lower <- function(theta, d_matrix, a_subset, j0_vector, v_bar, z_matrix = 1, dist_subset = NULL) {
  # number of firms
  num_firms <- length(unique(j0_vector[, 2]))

  if (num_firms != length(theta)) {
    stop("error on dimension of theta")
  }

  # Create vector of theta values matched to the firm of each product
  theta_vector <- theta[j0_vector[, 2]]

  # Run equation (26) for each product
  (t(t(a_subset) - theta_vector) * (1 - d_matrix) - v_bar * d_matrix) * z_matrix
}

#' Upper Moment Inequality Function
#'
#' @param theta a vector containing the parameters of interest.
#' @param d_matrix an n x j0 matrix of product portfolio in each market.
#' @param a_subset an n x j0 matrix of estimated revenue differential in each
#'   market.
#' @param j0_vector a j0 x 2 matrix of ownership by the two firms.
#' @param v_bar a tuning parameter as in Assumption 4.2.
#' @param z_matrix an optional n x j0 matrix of instruments in each market.
#' @param dist_subset an optional n x j0 matrix of distance between products in
#'   each market.
#'
#' @return a j0-dimensional vector of upper moment inequalities.
#' @export
m_fun_upper <- function(theta, d_matrix, a_subset, j0_vector, v_bar, z_matrix = 1, dist_subset = NULL) {
  # Moment function upper is moment function lower with two substitutions:
  # 1. theta is negated
  # 2. d_matrix replaced with 1 - d_matrix
  m_fun_lower(
    a_subset = a_subset,
    d_matrix = 1 - d_matrix,
    z_matrix = z_matrix,
    j0_vector = j0_vector,
    theta = -theta,
    v_bar = v_bar,
    dist_subset = dist_subset
  )
}
