# Moment inequality function defined in eq (28)

# there are four main steps
# step 1: select moments with non-zero variance using ml_indx & mu_indx
# step 2: load instruments in case we use them
# step 3: compute all the moment functions
# step 4: select the cumputed moments using ml_indx & mu_indx defined in step 1

# comment:
# - all the inputs are included in 'Amatrix200701_fake.mat'.
# - W_data = D_matrix(:,2:end);
# - J1 is the number of moments w/ no zero variance, see section 8.1.
# - n is the number of markets

m_function <- function(W_data, A_matrix, theta, J0_vec, Vbar, IV, grid0){

    # input:
    # - W_data          n  x J          matrix of all product portfolio
    # - A_matrix        n  x (1+J0)     matrix of revenue differential
    # - theta      d_theta x 1          parameter of interest
    # - J0_vec          J0 x 2          matrix of ownership by two firms
    # - Vbar                            tuning parameter as in Assumption 4.2
    # - IV       matrix(c(NA, NA), nrow = 1, ncol = 1)  instruments
    # - grid0       matrix(c(1, 2, NA), nrow = 1, ncol = 3)       searching direction

    # output:
    # - salida          1 x J1          vector of the moment function.

    n <- (dim(A_matrix)[1])
    J0 <- (dim(J0_vec)[1])

    if ((dim(W_data)[1]) != n){
        cat('wrong number of observations')
        cat((dim(A_matrix)[1]))
        cat(n)
        cat('wrong')
        keyboard
    }

    ## step 1: select moments with non-zero variance using ml_indx & mu_indx
    #          the procedure follows the discussion of section 8.1

    aux1 <- sum(W_data)
    aux1 <- aux1(J0_vec(:, 1))

    ml_indx <- []
    mu_indx <- []

    for (jj0 in 1:J0){

        if (aux1(jj0) < n){

            if (strcmp(grid0, 'all')){# include all the possible moments generated by products of coca-cola or energy-products
                ml_indx <- [ml_indx; jj0]
            } else {
                jj1 <- grid0# include only the possible moments generated by coca-cola (grid0=1) or energy-products (grid0=2)

                if (J0_vec(jj0, 2) == jj1){
                    ml_indx <- [ml_indx; jj0]
                }

            }

        }

        if (aux1(jj0) > 0){

            if (strcmp(grid0, 'all')){# include all the possible moments generated by products of coca-cola or energy-products
                mu_indx <- [mu_indx; jj0]
            } else {
                jj1 <- grid0# include only the possible moments generated by coca-cola (grid0=1) or energy-products (grid0=2)

                if (J0_vec(jj0, 2) == jj1){
                    mu_indx <- [mu_indx; jj0]
                }

            }

        }

    }

    ## step 2: load instruments in case we use them
    #          the instruments are presented in section 8.2

    if (strcmp(IV, 'demographics')){
        load('Amatrix200701_fake.mat', 'IV_matrix')
    }

    ## step 3: compute all the moment functions

    for (mm0 in 1:n){
        #
        A_vec <- A_matrix(mm0, 2:J0 + 1)'# vector of estimated revenue differential in market mm0
        D_vec <- W_data(mm0, :)'
        D_vec <- D_vec(J0_vec(:, 1))# vector of product portfolio of coca-cola and energy-products in market mm0

        if (strcmp(IV, 'N')){
            Z_vec <- rep(1, 1)
            ml_vec <- MomentFunct_L(A_vec, D_vec, Z_vec, J0_vec, theta, Vbar)
            mu_vec <- MomentFunct_U(A_vec, D_vec, Z_vec, J0_vec, theta, Vbar)

            X_data(mm0, :) <- [ml_vec(ml_indx) mu_vec(mu_indx)]

        } else if (strcmp(IV, 'demographics')){
            Z_vec <- rep(1, 1)
            Z3_vec <- 1 * (IV_matrix(:, 2) > median(IV_matrix(:, 2)))# employment rate
            Z5_vec <- 1 * (IV_matrix(:, 3) > median(IV_matrix(:, 3)))# average income in market
            Z7_vec <- 1 * (IV_matrix(:, 4) > median(IV_matrix(:, 4)))# median income in market

            ml_vec <- MomentFunct_L(A_vec, D_vec, Z_vec, J0_vec, theta, Vbar)
            ml_vec3 <- MomentFunct_L(A_vec, D_vec, Z3_vec, J0_vec, theta, Vbar)
            ml_vec5 <- MomentFunct_L(A_vec, D_vec, Z5_vec, J0_vec, theta, Vbar)
            ml_vec7 <- MomentFunct_L(A_vec, D_vec, Z7_vec, J0_vec, theta, Vbar)

            mu_vec <- MomentFunct_U(A_vec, D_vec, Z_vec, J0_vec, theta, Vbar)
            mu_vec3 <- MomentFunct_U(A_vec, D_vec, Z3_vec, J0_vec, theta, Vbar)
            mu_vec5 <- MomentFunct_U(A_vec, D_vec, Z5_vec, J0_vec, theta, Vbar)
            mu_vec7 <- MomentFunct_U(A_vec, D_vec, Z7_vec, J0_vec, theta, Vbar)

            X2_data(mm0, :) <- [ml_vec(ml_indx) mu_vec(mu_indx) ...
                                  ml_vec3(ml_indx) mu_vec3(mu_indx) ...
                                  ml_vec5(ml_indx) mu_vec5(mu_indx) ...
                                  ml_vec7(ml_indx) mu_vec7(mu_indx)]

        }

    }

    ## step 4: select the computed moments using ml_indx & mu_indx defined in step 1

    if (strcmp(IV, 'N')){
        salida <- X_data
    } else if (strcmp(IV, 'demographics')){
        salida <- X2_data
    }

}
