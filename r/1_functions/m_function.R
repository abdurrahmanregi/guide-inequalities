# Moment inequality function defined in eq (28)

# there are four main steps
# step 1: select moments with non-zero variance using ml_indx & mu_indx
# step 2: compute all the moment functions
# step 3: select the cumputed moments using ml_indx & mu_indx defined in step 1

# comment:
# - all the inputs are included in 'Amatrix200701_fake.mat'.
# - W_data = D_matrix(:,2:end);
# - J1 is the number of moments w/ no zero variance, see section 8.1.
# - n is the number of markets
# input:
# - W_data          n  x J          matrix of all product portfolio
# - A_matrix        n  x (1+J0)     matrix of revenue differential
# - theta      d_theta x 1          parameter of interest
# - J0_vec          J0 x 2          matrix of ownership by two firms
# - Vbar                            tuning parameter as in Assumption 4.2
# - IV_matrix   matrix(c(NA, NA, NA, NA), nrow = 1, ncol = 1)      instruments (empty if no instruments)
# - grid0       matrix(c(1, 2, NA), nrow = 1, ncol = 3)       searching direction

# output:
# - salida          n x J1          vector of the moment function.

m_function <- function(W_data, A_matrix, theta, J0_vec, Vbar, IV_matrix, grid0) {
  n <- nrow(A_matrix)
  J0 <- nrow(J0_vec)

  if (nrow(W_data) != n) {
    stop(sprintf("Wrong number of observations! %s != %s.", nrow(A_matrix), n))
  }

  ## step 1: select moments with non-zero variance using ml_indx & mu_indx
  #          the procedure follows the discussion of section 8.1

  aux1 <- Rfast::colsums(W_data)
  aux1 <- aux1[J0_vec[, 1]]

  if (grid0 == "all") {
    # include all the possible moments generated by products of coca-cola or energy-products
    ml_indx <- (1:J0)[aux1 < n]
    mu_indx <- (1:J0)[aux1 > 0]
  } else if (grid0 %in% 1:2) {
    # include only the possible moments generated by coca-cola (grid0=1) or energy-products (grid0=2)
    ml_indx <- (1:J0)[aux1 < n & J0_vec[, 2] == grid0]
    mu_indx <- (1:J0)[aux1 > 0 & J0_vec[, 2] == grid0]
  } else {
    stop(sprintf("grid 0 must be one of all,0,1. You entered %s.", grid0))
  }

  ## step 2: compute all the moment functions
  if (is.null(IV_matrix)) {
    # Initialize output
    X_data <- matrix(NA, nrow = n, ncol = length(ml_indx) + length(mu_indx))

    # Create dummy IV vector
    Z_vec <- rep(1, J0)

    for (mm0 in 1:n) {
      # vector of estimated revenue differential in market mm0
      A_vec <- A_matrix[mm0, 2:(J0 + 1)]
      # vector of product portfolio of coca-cola and energy-products in market mm0
      D_vec <- W_data[mm0, J0_vec[, 1]]

      ml_vec <-
        MomentFunct_L(A_vec, D_vec, Z_vec, J0_vec, theta, Vbar)
      mu_vec <-
        MomentFunct_U(A_vec, D_vec, Z_vec, J0_vec, theta, Vbar)

      X_data[mm0, ] <- c(ml_vec[ml_indx], mu_vec[mu_indx])
    }
  } else {
    # Initialize output
    X_data <-
      matrix(NA, nrow = n, ncol = 4 * (length(ml_indx) + length(mu_indx)))

    # Create dummy IV vector
    Z_vec <- rep(1, J0)
    # employment rate
    Z3_vec <-
      as.numeric(IV_matrix[, 2] > median(IV_matrix[, 2]))
    # average income in market
    Z5_vec <-
      as.numeric(IV_matrix[, 3] > median(IV_matrix[, 3]))
    # median income in market
    Z7_vec <-
      as.numeric(IV_matrix[, 4] > median(IV_matrix[, 4]))

    for (mm0 in 1:n) {
      # vector of estimated revenue differential in market mm0
      A_vec <- A_matrix[mm0, 2:(J0 + 1)]
      # vector of product portfolio of coca-cola and energy-products in market mm0
      D_vec <- W_data[mm0, J0_vec[, 1]]

      ml_vec <-
        MomentFunct_L(A_vec, D_vec, Z_vec, J0_vec, theta, Vbar)
      ml_vec3 <-
        MomentFunct_L(A_vec, D_vec, Z3_vec, J0_vec, theta, Vbar)
      ml_vec5 <-
        MomentFunct_L(A_vec, D_vec, Z5_vec, J0_vec, theta, Vbar)
      ml_vec7 <-
        MomentFunct_L(A_vec, D_vec, Z7_vec, J0_vec, theta, Vbar)

      mu_vec <-
        MomentFunct_U(A_vec, D_vec, Z_vec, J0_vec, theta, Vbar)
      mu_vec3 <-
        MomentFunct_U(A_vec, D_vec, Z3_vec, J0_vec, theta, Vbar)
      mu_vec5 <-
        MomentFunct_U(A_vec, D_vec, Z5_vec, J0_vec, theta, Vbar)
      mu_vec7 <-
        MomentFunct_U(A_vec, D_vec, Z7_vec, J0_vec, theta, Vbar)

      X_data[mm0, ] <- c(
        ml_vec[ml_indx],
        mu_vec[mu_indx],
        ml_vec3[ml_indx],
        mu_vec3[mu_indx],
        ml_vec5[ml_indx],
        mu_vec5[mu_indx],
        ml_vec7[ml_indx],
        mu_vec7[mu_indx]
      )
    }
  }

  ## step 3: select the computed moments using ml_indx & mu_indx defined in step 1
  salida <- X_data
  return(salida)
}
