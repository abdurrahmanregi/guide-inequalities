# Moment inequality function defined in eq (28)

# there are four main steps
# step 1: select moments with non-zero variance using ml_indx & mu_indx
# step 2: compute all the moment functions
# step 3: select the cumputed moments using ml_indx & mu_indx defined in step 1

# comment:
# - all the inputs are included in 'Amatrix200701_fake.mat'.
# - W_data = D_matrix(:,2:end);
# - J1 is the number of moments w/ no zero variance, see section 8.1.
# - n is the number of markets
# input:
# - W_data          n  x J          matrix of all product portfolio
# - A_matrix        n  x (1+J0)     matrix of revenue differential
# - theta      d_theta x 1          parameter of interest
# - J0_vec          J0 x 2          matrix of ownership by two firms
# - Vbar                            tuning parameter as in Assumption 4.2
# - IV_matrix   matrix(c(NA, NA, NA, NA), nrow = 1, ncol = 1)      instruments (empty if no instruments)
# - grid0       matrix(c(1, 2, NA), nrow = 1, ncol = 3)       searching direction

# output:
# - salida          n x J1          vector of the moment function.

m_function <- function(W_data,
                       A_matrix,
                       theta,
                       J0_vec,
                       Vbar,
                       IV_matrix,
                       grid0)
{
  n <- nrow(A_matrix)
  J0 <- nrow(J0_vec)
  
  # Initialize output
  X_data <- NULL
  
  if (nrow(W_data) != n) {
    cat('wrong number of observations')
    cat(nrow(A_matrix))
    cat(n)
    cat('wrong')
    return()
  }
  
  ## step 1: select moments with non-zero variance using ml_indx & mu_indx
  #          the procedure follows the discussion of section 8.1
  
  aux1 <- Rfast::colsums(W_data)
  aux1 <- aux1[J0_vec[, 1]]
  
  ml_indx <- numeric()
  mu_indx <- numeric()
  
  for (jj0 in 1:J0) {
    if (aux1[jj0] < n) {
      if (grid0 == 'all') {
        # include all the possible moments generated by products of coca-cola or energy-products
        ml_indx <- c(ml_indx, jj0)
      } else {
        # include only the possible moments generated by coca-cola (grid0=1) or energy-products (grid0=2)
        jj1 <- grid0
        
        if (J0_vec[jj0, 2] == jj1) {
          ml_indx <- c(ml_indx, jj0)
        }
        
      }
    }
    
    if (aux1[jj0] > 0) {
      if (grid0 == 'all') {
        # include all the possible moments generated by products of coca-cola or energy-products
        mu_indx <- c(mu_indx, jj0)
      } else {
        # include only the possible moments generated by coca-cola (grid0=1) or energy-products (grid0=2)
        jj1 <- grid0
        
        if (J0_vec[jj0, 2] == jj1) {
          mu_indx <- c(mu_indx, jj0)
        }
        
      }
      
    }
    
  }
  
  ## step 2: compute all the moment functions
  
  for (mm0 in 1:n) {
    # vector of estimated revenue differential in market mm0
    A_vec <- A_matrix[mm0, 2:(J0 + 1)]
    # vector of product portfolio of coca-cola and energy-products in market mm0
    D_vec <- W_data[mm0, J0_vec[, 1]]
    
    if (is.na(IV_matrix)) {
      Z_vec <- rep(1, J0)
      ml_vec <-
        MomentFunct_L(A_vec, D_vec, Z_vec, J0_vec, theta, Vbar)
      mu_vec <-
        MomentFunct_U(A_vec, D_vec, Z_vec, J0_vec, theta, Vbar)
      
      X_data <- rbind(X_data, c(ml_vec[ml_indx], mu_vec[mu_indx]))
      
    } else {
      Z_vec <- rep(1, J0)
      # employment rate
      Z3_vec <-
        as.numeric(IV_matrix[, 2] > median(IV_matrix[, 2]))
      # average income in market
      Z5_vec <-
        as.numeric(IV_matrix[, 3] > median(IV_matrix[, 3]))
      # median income in market
      Z7_vec <-
        as.numeric(IV_matrix[, 4] > median(IV_matrix[, 4]))
      
      ml_vec <-
        MomentFunct_L(A_vec, D_vec, Z_vec, J0_vec, theta, Vbar)
      ml_vec3 <-
        MomentFunct_L(A_vec, D_vec, Z3_vec, J0_vec, theta, Vbar)
      ml_vec5 <-
        MomentFunct_L(A_vec, D_vec, Z5_vec, J0_vec, theta, Vbar)
      ml_vec7 <-
        MomentFunct_L(A_vec, D_vec, Z7_vec, J0_vec, theta, Vbar)
      
      mu_vec <-
        MomentFunct_U(A_vec, D_vec, Z_vec, J0_vec, theta, Vbar)
      mu_vec3 <-
        MomentFunct_U(A_vec, D_vec, Z3_vec, J0_vec, theta, Vbar)
      mu_vec5 <-
        MomentFunct_U(A_vec, D_vec, Z5_vec, J0_vec, theta, Vbar)
      mu_vec7 <-
        MomentFunct_U(A_vec, D_vec, Z7_vec, J0_vec, theta, Vbar)
      
      X_data <- rbind(
        X_data,
        c(
          ml_vec[ml_indx],
          mu_vec[mu_indx],
          ml_vec3[ml_indx],
          mu_vec3[mu_indx],
          ml_vec5[ml_indx],
          mu_vec5[mu_indx],
          ml_vec7[ml_indx],
          mu_vec7[mu_indx]
        )
      )
    }
    
  }
  
  ## step 3: select the computed moments using ml_indx & mu_indx defined in step 1
  salida <- X_data
  return(salida)
}
